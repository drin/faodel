// Copyright 2018 National Technology & Engineering Solutions of Sandia, 
// LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS,  
// the U.S. Government retains certain rights in this software. 

/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <nnti/nnti_packable.h>
#include "nnti/nntiConfig.h"
#include "nnti/nnti_xdr.h"

bool_t
xdr_NNTI_datatype_t (XDR *xdrs, NNTI_datatype_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_transport_id_t (XDR *xdrs, NNTI_transport_id_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_ip_addr (XDR *xdrs, NNTI_ip_addr *objp)
{
	register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_tcp_port (XDR *xdrs, NNTI_tcp_port *objp)
{
	register int32_t *buf;

	 if (!xdr_uint16_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_null_process_p_t (XDR *xdrs, NNTI_null_process_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->i))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_ib_process_p_t (XDR *xdrs, NNTI_ib_process_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_NNTI_ip_addr (xdrs, &objp->addr))
		 return FALSE;
	 if (!xdr_NNTI_tcp_port (xdrs, &objp->port))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_instance_id (XDR *xdrs, NNTI_instance_id *objp)
{
	register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_ugni_process_p_t (XDR *xdrs, NNTI_ugni_process_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_NNTI_ip_addr (xdrs, &objp->addr))
		 return FALSE;
	 if (!xdr_NNTI_tcp_port (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_NNTI_instance_id (xdrs, &objp->inst_id))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_mpi_process_p_t (XDR *xdrs, NNTI_mpi_process_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->rank))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_local_process_p_t (XDR *xdrs, NNTI_local_process_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->i))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_remote_process_p_t (XDR *xdrs, NNTI_remote_process_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_NNTI_transport_id_t (xdrs, &objp->transport_id))
		 return FALSE;
	switch (objp->transport_id) {
	case NNTI_TRANSPORT_NULL:
		 if (!xdr_NNTI_null_process_p_t (xdrs, &objp->NNTI_remote_process_p_t_u.null))
			 return FALSE;
		break;
	case NNTI_TRANSPORT_IBVERBS:
		 if (!xdr_NNTI_ib_process_p_t (xdrs, &objp->NNTI_remote_process_p_t_u.ib))
			 return FALSE;
		break;
	case NNTI_TRANSPORT_UGNI:
		 if (!xdr_NNTI_ugni_process_p_t (xdrs, &objp->NNTI_remote_process_p_t_u.ugni))
			 return FALSE;
		break;
	case NNTI_TRANSPORT_MPI:
		 if (!xdr_NNTI_mpi_process_p_t (xdrs, &objp->NNTI_remote_process_p_t_u.mpi))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_NNTI_process_id_t (XDR *xdrs, NNTI_process_id_t *objp)
{
	register int32_t *buf;

	 if (!xdr_uint64_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_peer_p_t (XDR *xdrs, NNTI_peer_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_NNTI_datatype_t (xdrs, &objp->datatype))
		 return FALSE;
	 if (!xdr_NNTI_process_id_t (xdrs, &objp->pid))
		 return FALSE;
	 if (!xdr_NNTI_remote_process_p_t (xdrs, &objp->peer))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_null_rdma_addr_p_t (XDR *xdrs, NNTI_null_rdma_addr_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->i))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_ib_rdma_addr_p_t (XDR *xdrs, NNTI_ib_rdma_addr_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_uint64_t (xdrs, &objp->buf))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->key))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->size))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_ugni_mem_hdl_p_t (XDR *xdrs, NNTI_ugni_mem_hdl_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_uint64_t (xdrs, &objp->qword1))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->qword2))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_ugni_rdma_addr_p_t (XDR *xdrs, NNTI_ugni_rdma_addr_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_uint64_t (xdrs, &objp->buf))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->size))
		 return FALSE;
	 if (!xdr_NNTI_ugni_mem_hdl_p_t (xdrs, &objp->mem_hdl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_match_bits (XDR *xdrs, NNTI_match_bits *objp)
{
	register int32_t *buf;

	 if (!xdr_uint64_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_mpi_rdma_addr_p_t (XDR *xdrs, NNTI_mpi_rdma_addr_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_NNTI_match_bits (xdrs, &objp->cmd_tag))
		 return FALSE;
	 if (!xdr_NNTI_match_bits (xdrs, &objp->get_data_tag))
		 return FALSE;
	 if (!xdr_NNTI_match_bits (xdrs, &objp->put_data_tag))
		 return FALSE;
	 if (!xdr_NNTI_match_bits (xdrs, &objp->atomic_data_tag))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->buf))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->size))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_local_rdma_addr_p_t (XDR *xdrs, NNTI_local_rdma_addr_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->i))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NNTI_remote_addr_p_t (XDR *xdrs, NNTI_remote_addr_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_NNTI_transport_id_t (xdrs, &objp->transport_id))
		 return FALSE;
	switch (objp->transport_id) {
	case NNTI_TRANSPORT_NULL:
		 if (!xdr_NNTI_null_rdma_addr_p_t (xdrs, &objp->NNTI_remote_addr_p_t_u.null))
			 return FALSE;
		break;
	case NNTI_TRANSPORT_IBVERBS:
		 if (!xdr_NNTI_ib_rdma_addr_p_t (xdrs, &objp->NNTI_remote_addr_p_t_u.ib))
			 return FALSE;
		break;
	case NNTI_TRANSPORT_UGNI:
		 if (!xdr_NNTI_ugni_rdma_addr_p_t (xdrs, &objp->NNTI_remote_addr_p_t_u.ugni))
			 return FALSE;
		break;
	case NNTI_TRANSPORT_MPI:
		 if (!xdr_NNTI_mpi_rdma_addr_p_t (xdrs, &objp->NNTI_remote_addr_p_t_u.mpi))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_NNTI_buffer_p_t (XDR *xdrs, NNTI_buffer_p_t *objp)
{
	register int32_t *buf;

	 if (!xdr_NNTI_remote_addr_p_t (xdrs, &objp->buffer))
		 return FALSE;
	 if (!xdr_uint8_t (xdrs, &objp->flags))
		 return FALSE;
	return TRUE;
}
