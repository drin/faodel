// Copyright 2018 National Technology & Engineering Solutions of Sandia, 
// LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS,  
// the U.S. Government retains certain rights in this software. 

#include <string>
#include <cstring>
#include <iostream>

#include "opbox/OpBox.hh"

#include <capnp/message.h>
#include <capnp/serialize-packed.h>

using namespace std;


// This header is generated by running 'capnpc-c++ -oc++ fancypants.fbs'. Set CAPNPROTO_ROOT in the
// environment to the install root of your copy of Cap'n Proto and see CMakeLists.txt
#include "fancypants.capnp.h"

/*
 * To contrast with the FlatBuffers example, in which we maintained our own FancyPants
 * objects and did copy-in/copy-out from the FlatBuffers generated classes, in this
 * example we forego our own classes and show what it would be like to just use 
 * the ones Cap'n Proto generates for us. Mostly, that difference disappears under
 * the syntax required for each library, but it's still a useful point.
 */


ostream&
operator<<( ostream& ostr, const FancyPantsCp::Reader& fpr )
{
  ostr << fpr.getColor().cStr() << ":" << fpr.getName().cStr() << endl;

  for( PocketCp::Reader pcr : fpr.getPockets() ) {
    ostr << ((pcr.getIsFront())?"front-":"back-")
	 << ((pcr.getIsLeft())?"left":"right")
	 << " pocket" << endl;
  }

  return ostr;
}
    
    

void
example6_capnproto_messages()
{

  cout << endl
       << "*********************************"
       << "  Cap'n Proto serialization  " 
       << "*********************************"
       << endl;

  capnp::MallocMessageBuilder cp_msg;
  FancyPantsCp::Builder my_pants = cp_msg.initRoot< FancyPantsCp >();
  capnp::List< PocketCp >::Builder my_pockets = my_pants.initPockets( 4 );

  for( auto i = 0; i < 4; i++ ) {
    PocketCp::Builder pb = my_pockets[i];
    pb.setIsLeft( ( i & 0x01 ) );
    pb.setIsFront( ( i & 0x02 ) );
  }

  my_pants.setName( "britches" );
  my_pants.setColor( "green" );

  auto msg_as_wordarray = messageToFlatArray( cp_msg );
  auto msg_as_bytearray = msg_as_wordarray.asBytes();

  // Our use case (essentially marshal to/from a void* buffer) isn't strongly served by CP.
  //  CP wants to be your RPC system, and supplies a (very very efficient) serialization
  //  system as part of that. If you were building a set of internal services, for example,
  //  you could rely on CP to serialize your data and write it to a file descriptor/socket,
  //  and to read incoming messages from the fd/socket and inflate them for use by your server.
  //  Although CP has all the right API pieces to do what we'd want it to do, you can
  //  tell that CP aims at a different target.
  
  // Some opbox/lunasa boilerplate to set up an LDO with a message body of an
  // arbitrary struct. Perhaps there's a better way to do this but I couldn't
  // figure it out.
  lunasa::DataObject* ldo = opbox::net::NewMessage( sizeof( message_t ) + msg_as_bytearray.size() );
  message_t *msg = reinterpret_cast< message_t* >( ldo->dataPtr() );

  // Use the size of the marshaled buffer in the CP builder as the length of the payload
  msg->body_len = msg_as_bytearray.size();
  // Copy the CP builder's marshaled buffer to the LDO 
  std::memcpy( msg->body, msg_as_bytearray.begin(), msg->body_len );

  cout << "Packed size is " << msg->body_len << endl;
  cout << "LDO size is " << ldo->dataSize() << endl;

  // Get the message back out of the LDO, as though we'd received it from a sender
  auto *msg2 = reinterpret_cast< message_t* >( ldo->dataPtr() );

  // This is a bit of an assumption about the input data. CP tries very hard
  //  to never do a read that isn't aligned on a word boundary, for performance sake.
  //  That's why CP has its own capnp::word type. If you wanted to use CP in your project,
  //  you might consider having a message type whose body was an array of capnp::word
  //  to get around having to do the char->capnp::word conversion. So this will work,
  //  but if the data in msg->body isn't word-aligned you'll give up some performance.
  //
  //  CP does have ways to get around this (essentially, to make sure a foreign buffer is
  //  word-aligned, either you have to make a copy or you let CP make a copy) but they require
  //  you to dig into the CP source to figure out how to do them, and CP is lacking in both
  //  documentation and examples.
  //
  //  Lastly, the kj:: namespace is provided in a separate support
  //  library included in the CP package upon which CP relies
  //  (libkj.a). It gets built and installed alongisde the CP
  //  libraries during their build process.
  kj::ArrayPtr< const capnp::word > words( reinterpret_cast< const capnp::word* >( msg->body ),
					   msg->body_len / sizeof( capnp::word ) );
  capnp::FlatArrayMessageReader cp_msg2 ( words );
  FancyPantsCp::Reader msg_reader = cp_msg2.getRoot< FancyPantsCp >();
  
  cout << "Original pants:" << endl << my_pants << endl;
  cout << "Unpacked pants:" << endl << msg_reader << endl;
						   
  delete ldo;
}

  
  
