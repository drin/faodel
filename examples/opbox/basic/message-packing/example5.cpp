// Copyright 2021 National Technology & Engineering Solutions of Sandia, LLC
// (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
// Government retains certain rights in this software.

#include <string>
#include <iostream>

#include "opbox/OpBox.hh"

// This header is generated by running 'flatc --cpp fancypants.fbs. Set FLATBUFFERS_ROOT in the
// environment to the install root of your copy of FlatBuffers and see CMakeLists.txt
#include "fancypants_generated.h"

using namespace std;

namespace flatbuffers_example {
  
  class Pocket
  {
  public:
    Pocket( bool is_left = false, bool is_front = false )
      : is_left_( is_left ), is_front_( is_front )
    {};
    
    bool is_left_, is_front_;
  };
  
  class FancyPants
  {
  public:
    
    FancyPants( const string& name = "", const string& color = "", int num_pockets = 0 )
      : name_( name ), color_( color )
    {
      for( auto i = 0; i < num_pockets; i++ )
	pockets_.push_back( Pocket ( (i & 0x01), (i & 0x02) ) );
    };
    
    string name_, color_;
    vector< Pocket > pockets_;
  };
  
  
  ostream&
  operator<<( ostream& ostr, const FancyPants& fp )
  {
    ostr << fp.color_ << ":" << fp.name_ << endl;
    
    for( auto &&p : fp.pockets_ ) {
      ostr << ((p.is_front_)?"front-":"back-")
	   << ((p.is_left_)?"left":"right") << " pocket" << endl;
    }
    return ostr;
  }

};
/*
 *  So far similar to the boost example
 */


  
void
example5_flatbuffer_messages()
{
  using namespace flatbuffers_example;
  cout << endl
       << "*********************************"
       << "  FlatBuffers serialization  " 
       << "*********************************"
       << endl;
  
  lunasa::DataObject *ldo;

  FancyPants my_pants( "britches", "red", 4 );

  /* We use this builder object to incrementally construct a packed buffer */
  flatbuffers::FlatBufferBuilder fbb;

  /* 
   *  Here is the main perversity of FlatBuffers.
   *
   *  FB wants to "own" the class that holds the data it will (un)marshal. So, once you
   *  generate the stub header using the flatc compiler, you can either use the
   *  FB classes in that header to hold your data as your program works with it,
   *  or you have to go through some hoops to transfer your program's data into the FB
   *  classes which know how to (un)marshal. 
   *
   *  Using their classes is an option if your classes and their hierarchy aren't 
   *  too complex, but already in this small example we run into a case where FB
   *  shows its rough edges. FB does very well with structures which contain arrays
   *  of primitive types, but as soon as you introduce member data of user-defined 
   *  types, the complexity goes up. Here, we have FancyPants which contains 
   *  vector<Pocket>. In the .fbs file with the structure definitions, this gets described
   *  as you might think: pockets:[Pocket]. It's an exercise for the reader to look at the generated
   *  header and see the difference in what gets produced for this versus, say, if FancyPants 
   *  contained vector<uint_32> instead.
   *
   *  Anyway, because of this situation, the classes in the .fbs file are named FancyPants_fb and Pocket_fb,
   *  and we have to declare and populate some separate data structures in order to get FB to work.
   *
   */

  // First build a vector of Pocket_fb and copy contents
  vector< Pocket_fb > fp_pockets;
  for( auto&& pp : my_pants.pockets_ ) {
    fp_pockets.push_back( Pocket_fb( pp.is_left_, pp.is_front_ ) );
  }

  // Since the other things in FancyPants are "primitive" data (std::string isn't primitive, but FB
  // has built-in support for it), we can move directly to creating the "peer" FB object which
  // we'll use to marshal the contents of our FancyPants object.
  auto packed_pants = CreateFancyPants_fb( fbb,
					   fbb.CreateString( my_pants.name_ ),
					   fbb.CreateString( my_pants.color_ ),
					   fbb.CreateVectorOfStructs( fp_pockets ) );

  // Tell FB we're done adding to this builder.
  fbb.Finish( packed_pants );

  // Some opbox/lunasa boilerplate to set up an LDO with a message body of an
  // arbitrary struct. Perhaps there's a better way to do this but I couldn't
  // figure it out.
  ldo = opbox::net::NewMessage( sizeof( message_t ) + fbb.GetSize() );
  message_t *msg = reinterpret_cast< message_t* >( ldo->dataPtr() );

  // Use the size of the marshaled buffer in the FB builder as the length of the payload
  msg->body_len = fbb.GetSize();
  // Copy the FB builder's marshaled buffer to the LDO 
  std::memcpy( msg->body, fbb.GetBufferPointer(), msg->body_len );

  cout << "Packed flatbuffer size is " << msg->body_len << endl;
  cout << "LDO size is " << ldo->dataSize() << endl;

  // Again, we have to do some footwork. Pass the LDO payload to a generated function
  // which returns to us an object which knows how to look inside the marshaled buffer.
  auto *msg2 = reinterpret_cast< message_t* >( ldo->dataPtr() );

  const FancyPants_fb *fp2 = GetFancyPants_fb( msg2->body );

  // extract data from the FB object into a second FancyPants
  FancyPants my_other_pants( fp2->name()->str(), fp2->color()->str() ); // pass 0 for num_pockets as default value

  // Again, we have to manually populate the pockets because of FB limitations
  auto packed_pockets = fp2->pockets();
  // Adding to the flavor, doing this with a ranged for loop doesn't work well because
  // packed_pockets->Get() performs some FB pointer magic that's hard to do otherwise.
  for( auto i = 0; i < packed_pockets->Length(); i++ ) {
    my_other_pants.pockets_.push_back( Pocket( packed_pockets->Get(i)->is_left(), packed_pockets->Get(i)->is_front() ) );
  }

  // All done. Let's see what happened.
  cout << "Original pants:" << endl << my_pants << endl;  
  cout << "unpacked pants:" << endl << my_other_pants;

  delete ldo;

}
  
